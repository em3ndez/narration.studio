{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../../App.svelte",
    "../../Guide.svelte",
    "../../Editor.svelte",
    "../../ScriptDisplay.svelte",
    "../../PlayCursor.svelte",
    "../../Timestamps.svelte",
    "../../AudioTokenOverlay.svelte",
    "../../SilenceTokenOverlay.svelte",
    "../../TokensOverlay.svelte",
    "../../AudioRecorder.svelte",
    "../../ScriptEntry.svelte"
  ],
  "sourcesContent": [
    "<script lang=\"ts\">import { canLoad } from \"./editing/persistence\";\nimport LoadedSetup from \"./LoadedSetup.svelte\";\nimport NewSetup from \"./NewSetup.svelte\";\nimport Bowser from \"bowser\";\nimport Guide from \"./Guide.svelte\";\nconst browser = Bowser.getParser(window.navigator.userAgent);\nconst isValidBrowser = browser.satisfies({\n    chrome: \">=69\",\n    edge: \">=79\"\n}) || false;\nlet loadFromSave = null;\n//# sourceMappingURL=App.svelte.js.map</script>\n\n<style>\n  .column {\n    display: flex;\n    flex-direction: column;\n    justify-content: flex-start;\n    align-items: center;\n    height: 100%;\n    width: 100%;\n  }\n\n  .unsupported {\n    color: red;\n  }\n\n  .explanation {\n    max-width: 600px;\n    margin-left: 100px;\n    margin-right: 100px;\n    text-align: center;\n    font-size: 16px;\n  }\n\n  :global(body) {\n    overflow: hidden;\n    padding: 0;\n  }\n\n  :global(h1) {\n    font-size: 36px;\n    color: #444;\n    margin-block-start: 0.2em;\n    margin-block-end: 0.2em;\n  }\n\n  :global(h2) {\n    font-size: 28px;\n    color: #444;\n  }\n\n  :global(h3) {\n    font-size: 20px;\n    color: #444;\n  }\n\n  :global(button) {\n    font-size: 20px;\n    background-color: lightskyblue;\n    border: none;\n    border-radius: 10px;\n    padding: 10px;\n  }\n\n  :global(button:disabled) {\n    font-size: 20px;\n    background-color: lightsteelblue;\n    border: none;\n    border-radius: 10px;\n    padding: 10px;\n  }\n\n  .clickable {\n    cursor: pointer;\n  }\n\n  .github {\n    position: fixed;\n    top: 10px;\n    left: 10px;\n    color: lightskyblue;\n  }\n\n  .plug {\n    position: fixed;\n    top: 10px;\n    right: 10px;\n    color: lightskyblue;\n  }\n</style>\n\n<span class=\"github\"><a href=\"https://github.com/stevenwaterman/narration.studio\">View the Source on GitHub</a></span>\n<span class=\"plug\"><a href=\"https://www.stevenwaterman.uk\">by Steven Waterman</a></span>\n\n<div class=\"column\">\n  <h1 class:clickable={loadFromSave !== null} on:click={() => {loadFromSave = null;}}>Narration.studio</h1>\n  {#if isValidBrowser}\n    {#if loadFromSave === null}\n      {#await canLoad()}\n        <h2>Checking for save data</h2>\n      {:then dataExists}\n        <Guide/>\n        {#if dataExists}\n          <h2>Saved data found</h2>\n          <div class=\"buttonRow\">\n            <button on:click={() => loadFromSave = false}>Start Again</button>\n            <button on:click={() => loadFromSave = true}>Load from Save</button>\n          </div>\n        {:else}\n          <div class=\"buttonRow\">\n            <button on:click={() => loadFromSave = false}>Start</button>\n          </div>\n        {/if}\n      {:catch error}\n        {error}\n      {/await}\n    {:else if loadFromSave}\n      <LoadedSetup/>\n    {:else}\n      <NewSetup/>\n    {/if}\n  {:else}\n    <h2 class=\"unsupported\">Unsupported Browser</h2>\n    <p class=\"explanation\">\n      You are using <strong>{browser.getBrowserName()} {browser.getBrowserVersion()}</strong>.\n      Only <a href=\"https://www.google.com/chrome/\">Google Chrome 69+</a> is supported.\n    </p>\n    <p class=\"explanation\">\n      Not in the sense that we haven't tested it, but in the sense that it legitimately won't work.\n      The entire app is built around the Web Speech Recognition API which only exists in Chrome.\n      Trust me, I'm a Firefox user and normally ignore these.\n    </p>\n    <h2>Sorry!</h2>\n  {/if}\n</div>\n",
    "<style>\n  h2 {\n    text-align: center;\n  }\n</style>\n\n<div>\n  <h2>Record a narration in 3 easy steps!</h2>\n  <ol>\n    <li>\n      <h3>Enter the script</h3>\n      <ul>\n        <li>Plain Text / CommonMark / GitHub Flavored Markdown</li>\n        <li>Supports links, images, tables, code blocks, and more!</li>\n      </ul>\n    </li>\n    <li>\n      <h3>Record the script</h3>\n      <ul>\n        <li>Read each line as it's shown to you</li>\n        <li>Don't like your delivery? Just say the last line again!</li>\n        <li>Got distracted and said something not in the script? It'll get cut!</li>\n        <li>5 second pause? 10 minute pause? It'll get cut!</li>\n        <li><strong>No manual input required</strong>, everything works with speech recognition</li>\n      </ul>\n    </li>\n    <li>\n      <h3>Edit the recording</h3>\n      <ul>\n        <li>Listen to the auto-edited recording</li>\n        <li>Adjust the start and end of each clip</li>\n        <li>Auto-saves, so leave and come back later!</li>\n        <li>Grab the script annotated with audio timestamps</li>\n        <li><strong>Download your edited audio as a high quality .wav file</strong></li>\n      </ul>\n    </li>\n  </ol>\n</div>",
    "<script lang=\"ts\">import { audioStatusStore, pause, play, sampleRate, save, stop, togglePause } from \"./processor\";\n;\nimport RenderController from \"./canvas/renderController\";\nimport Timestamps from \"./overlay/Timestamps.svelte\";\nimport PlayCursor from \"./overlay/PlayCursor.svelte\";\nimport TokensOverlay from \"./overlay/tokens/TokensOverlay.svelte\";\nimport { drag, dragEnd } from \"../drag\";\nimport ScriptDisplay from \"./ScriptDisplay.svelte\";\nimport { onMount } from \"svelte\";\nimport { saveChangedToken } from \"./persistence\";\nexport let tokens;\nexport let buffer;\nlet visibleTokens;\n$: visibleTokens = tokens.filter(token => token.type !== \"NOTHING\");\nlet audioDuration;\n$: audioDuration = buffer.length / sampleRate;\nlet canvas;\nlet controller = undefined;\nlet containerWidth = 0;\n$: canvasWidth = containerWidth - 30;\nlet canvasHeight = 0;\nlet scroll = 0;\nlet pixelsPerSecond = 200;\nonMount(() => {\n    const offscreen = canvas.transferControlToOffscreen();\n    controller = new RenderController(offscreen, buffer, tokens, scroll, pixelsPerSecond, canvasWidth, canvasHeight);\n});\nlet canvasWidthSecs;\n$: canvasWidthSecs = canvasWidth / pixelsPerSecond;\nlet canvasStartSecs;\n$: canvasStartSecs = scroll - canvasWidthSecs / 2;\nlet canvasEndSecs;\n$: canvasEndSecs = scroll + canvasWidthSecs / 2;\nlet canvasBounds;\n$: canvasBounds = { start: canvasStartSecs, end: canvasEndSecs };\nlet duration;\n$: duration = tokens.map(token => token.type === \"NOTHING\" ? 0 : token.duration).reduce((a, b) => a + b, 0);\nfunction setScroll(value) {\n    const widthSecs = canvasWidth / pixelsPerSecond;\n    const minScroll = -0.4 * widthSecs;\n    const maxScroll = duration + 0.4 * widthSecs;\n    scroll = Math.min(Math.max(minScroll, value), maxScroll);\n}\nfunction onWheel(event) {\n    if (!canvas)\n        return;\n    const width = canvas.width;\n    const { deltaX, deltaY, clientX, shiftKey } = event;\n    const offsetX = clientX - width / 2;\n    const oldMouseSecs = offsetX / pixelsPerSecond;\n    if (shiftKey) {\n        if (deltaY < 0)\n            pixelsPerSecond *= 1.2;\n        if (deltaY > 0)\n            pixelsPerSecond /= 1.2;\n        pixelsPerSecond = Math.min(100 * 1000, pixelsPerSecond);\n    }\n    else {\n        if (deltaY)\n            setScroll(scroll + deltaY / pixelsPerSecond);\n    }\n    if (deltaX)\n        setScroll(scroll + deltaX / pixelsPerSecond);\n    const newMouseSecs = offsetX / pixelsPerSecond;\n    const requiredScrolling = newMouseSecs - oldMouseSecs;\n    setScroll(scroll - requiredScrolling);\n}\nlet cursorPositionSeconds;\nfunction keypress(event) {\n    if (event.code === \"Space\") {\n        togglePause(tokens);\n    }\n}\nfunction timechange(event) {\n    const newTime = event.detail;\n    setScroll(newTime);\n}\nfunction renderScrollChange(scroll) {\n    if (controller) {\n        controller.updateScroll(scroll);\n    }\n}\n$: renderScrollChange(scroll);\nfunction renderZoomChange(pixelsPerSecond) {\n    if (controller) {\n        controller.updateZoom(pixelsPerSecond, scroll);\n    }\n}\n$: renderZoomChange(pixelsPerSecond);\nfunction renderSizeChange(width, height) {\n    if (controller) {\n        controller.updateSize(width, height);\n    }\n}\n$: renderSizeChange(canvasWidth, canvasHeight);\nfunction renderTokenChange(token) {\n    if (controller) {\n        controller.updateToken(token);\n    }\n}\nfunction setToken(token) {\n    tokens[token.idx] = token;\n    renderTokenChange(token);\n    saveChangedToken(token);\n    pause(tokens);\n}\n//# sourceMappingURL=Editor.svelte.js.map</script>\n\n<style>\n  .container {\n    display: flex;\n    flex-direction: column;\n    width: 100%;\n    align-items: center;\n    justify-content: flex-start;\n    flex-shrink: 1;\n    flex-grow: 1;\n    min-height: 0;\n  }\n\n  .canvasContainer {\n    position: relative;\n    min-height: 40vh;\n    width: 100%;\n    flex-grow: 1;\n    flex-shrink: 1;\n  }\n\n  canvas {\n    position: absolute;\n    top: 30px;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    width: 100%;\n    height: calc(100% - 30px);\n    cursor: ew-resize;\n    z-index: 0;\n  }\n\n  .buttonRow {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n    align-self: center;\n    font-size: 36px;\n  }\n\n  button {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n    margin: 10px;\n    width: 50px;\n    height: 50px;\n    user-select: none;\n    padding: 0;\n    font-size: 24px;\n  }\n\n  .instruction {\n    position: fixed;\n    bottom: 0;\n    margin: 4px;\n    font-size: 18px;\n  }\n\n  .left {\n    left: 0;\n  }\n\n  .right {\n    right: 0;\n  }\n</style>\n\n<div class=\"container\"\n  on:mousemove={drag}\n  on:mouseup|preventDefault={dragEnd}\n  on:mouseout|preventDefault|self={dragEnd}\n>\n  <ScriptDisplay {tokens} {scroll} {cursorPositionSeconds}/>\n\n  <div class=\"canvasContainer\"\n    on:wheel|preventDefault={onWheel}\n    on:contextmenu|preventDefault\n    bind:clientWidth={canvasWidth}\n    bind:clientHeight={canvasHeight}\n  >\n    <PlayCursor {scroll} {duration} {pixelsPerSecond} on:timechange={timechange}/>\n    <Timestamps bind:cursorPositionSeconds {scroll} {pixelsPerSecond} {duration} on:play={e => play(tokens, e.detail)}/>\n    <TokensOverlay tokens={visibleTokens} {scroll} {pixelsPerSecond}  {audioDuration} {canvasBounds} {setToken}/>\n    <canvas bind:this={canvas}/>\n  </div>\n  \n  <div class=\"buttonRow\">\n    <button on:click|preventDefault={() => togglePause(tokens)}>{$audioStatusStore.type === \"PLAYING\" ? \"⏸️\" : \"▶️\"}</button>\n    <button disabled={$audioStatusStore.type !== \"STOPPED\"} on:click|preventDefault={() => stop(tokens)}>⏹️</button>\n    <button on:click|preventDefault={() => save(tokens)} style=\"font-size: 30px\">↓</button>\n  </div>\n\n  <div class=\"instruction left\">Scroll to pan, hold shift to zoom</div>\n  <div class=\"instruction right\">Left-click drag to adjust offset and duration</div>\n</div>\n<svelte:body on:keypress={keypress}/>",
    "<script lang=\"ts\">;\nimport { audioStatusStore } from \"./processor\";\nimport ScriptTimestamp from \"./ScriptTimestamp.svelte\";\nexport let tokens;\nexport let scroll;\nexport let cursorPositionSeconds;\nlet playing;\n$: playing = $audioStatusStore.type === \"PLAYING\";\nlet playingCursorPositionSeconds;\n$: playingCursorPositionSeconds = playing ? scroll : null;\nlet currentTime;\n$: currentTime = playingCursorPositionSeconds === null ? cursorPositionSeconds : playingCursorPositionSeconds;\nfunction toDisplayTokens(tokens) {\n    const output = [];\n    let time = 0;\n    tokens.forEach(token => {\n        if (token.type === \"NOTHING\") {\n            output.push({\n                idx: token.idx,\n                raw: token.raw\n            });\n        }\n        else {\n            if (token.type === \"PARAGRAPH\") {\n                output.push({\n                    idx: token.idx,\n                    raw: token.raw,\n                    timestamp: {\n                        start: time,\n                        end: time + token.duration\n                    }\n                });\n            }\n            else if (output.length) {\n                const last = output[output.length - 1];\n                if (last.timestamp !== undefined) {\n                    last.timestamp.end += token.duration;\n                }\n            }\n            time += token.duration;\n        }\n    });\n    return output;\n}\nlet displayTokens;\n$: displayTokens = toDisplayTokens(tokens);\nlet highlightedDiv = undefined;\n$: highlightedDiv && highlightedDiv.scrollIntoView({\n    block: \"center\",\n    behavior: \"auto\"\n});\nfunction between(currentTime, timestamp) {\n    if (currentTime === null)\n        return false;\n    if (timestamp === undefined)\n        return false;\n    if (timestamp.start > currentTime)\n        return false;\n    if (timestamp.end <= currentTime)\n        return false;\n    return true;\n}\n//# sourceMappingURL=ScriptDisplay.svelte.js.map</script>\n\n<style>\n  .highlighted {\n    background-color: rgba(255, 255, 0, 0.5);\n  }\n\n  .container {\n    width: 1000px;\n    padding: 10px;\n    overflow-y: scroll;\n    border: 1px solid black;\n    flex-grow: 1;\n    flex-shrink: 1;\n    user-select: all;\n    white-space: break-spaces;\n    margin-top: 20px;\n    margin-bottom: 20px;\n  }\n</style>\n\n<div class=\"container\">\n  {#each displayTokens as {idx, raw, timestamp} (idx)}\n    {#if timestamp}\n      <ScriptTimestamp time={timestamp.start}/>\n    {/if}\n    \n    {#if between(currentTime, timestamp)}\n      <div class=\"highlighted\" bind:this={highlightedDiv}>{raw}</div>\n    {:else}\n      <div>{raw}</div>\n    {/if}\n  {/each}\n</div>",
    "<script lang=\"ts\">import { createEventDispatcher } from \"svelte\";\nimport { audioStatusStore } from \"../processor\";\nexport let duration;\nexport let scroll;\nexport let pixelsPerSecond;\nlet offset = 0;\nlet animationDuration;\nlet running = false;\nlet startTime;\nfunction animateFirst(timestamp) {\n    animationDuration = 1000 * (duration - offset);\n    if (animationDuration <= 0)\n        return;\n    startTime = timestamp;\n    if (!running) {\n        running = true;\n        animate(timestamp);\n    }\n}\nconst dispatch = createEventDispatcher();\nfunction animate(timestamp) {\n    const addedScroll = (timestamp - startTime) / 1000;\n    const newScroll = offset + addedScroll;\n    dispatch(\"timechange\", newScroll);\n    if (state === \"PLAYING\" && newScroll < duration)\n        requestAnimationFrame(animate);\n    else {\n        if (state === \"PLAYING\")\n            audioStatusStore.set({ type: \"STOPPED\" });\n        running = false;\n        startTime = undefined;\n    }\n}\nlet pauseOffset = 0;\nlet pauseLeft;\n$: pauseLeft = (pauseOffset - scroll) * pixelsPerSecond;\nlet state = \"STOPPED\";\naudioStatusStore.subscribe(status => {\n    state = status.type;\n    if (status.type === \"PLAYING\") {\n        offset = status.offset;\n        requestAnimationFrame(animateFirst);\n    }\n    else if (status.type === \"PAUSED\") {\n        pauseOffset = status.offset;\n    }\n});\n//# sourceMappingURL=PlayCursor.svelte.js.map</script>\n\n<style>\n  .playLine {\n    position: absolute;\n    width: 1px;\n    left: 50%;\n    right: 50%;\n    top: 30px;\n    bottom: 0;\n    transform: translateX(-50%);\n    background-color: red;\n    pointer-events: none;\n    z-index: 2;\n  }\n\n  .pauseLine {\n    position: absolute;\n    width: 1px;\n    top: 30px;\n    bottom: 0;\n    transform: translateX(calc(50vw - 50%));\n    background-color: red;\n    pointer-events: none;\n    z-index: 2;\n  }\n</style>\n\n{#if state === \"PLAYING\"}\n  <div class=\"playLine\"/>\n{:else if state === \"PAUSED\"}\n  <div class=\"pauseLine\" style={`left: ${pauseLeft}px;`}/>\n{/if}",
    "<script lang=\"ts\">import { createEventDispatcher } from \"svelte\";\nimport { fade } from \"svelte/transition\";\nexport let duration;\nexport let scroll;\nexport let pixelsPerSecond;\nlet clientWidth;\nlet timestampWidth;\n$: timestampWidth = clientWidth || 0;\nlet timestampCount;\n$: timestampCount = Math.floor(timestampWidth / 100);\nlet timestampPx;\n$: timestampPx = timestampWidth / timestampCount;\nlet widthSecs;\n$: widthSecs = timestampWidth / pixelsPerSecond;\nlet timestampPeriod;\n$: timestampPeriod = widthSecs / timestampCount;\nlet timestamps;\n$: timestamps = new Array(timestampCount)\n    .fill(null)\n    .map((_, idx) => ({ ts: scroll + timestampPeriod * (idx - timestampCount / 2 + 0.5), idx }))\n    .filter(({ ts }) => ts >= 0 && ts <= duration)\n    .map(({ ts, idx }) => ({\n    left: timestampPx * (idx + 0.5),\n    mins: Math.floor(ts / 60).toFixed().padStart(2, \"0\"),\n    secs: (ts % 60).toFixed(3).padStart(6, \"0\")\n}));\nlet hovering = false;\nlet cursorPosition = null;\nexport let cursorPositionSeconds;\n$: cursorPositionSeconds = cursorPosition === null ? null : scroll + cursorPosition / pixelsPerSecond;\nlet minMousePosition;\n$: minMousePosition = -scroll * pixelsPerSecond;\nlet maxMousePosition;\n$: maxMousePosition = duration * pixelsPerSecond + minMousePosition;\nfunction mouseEnter() {\n    hovering = true;\n}\nfunction mouseLeave() {\n    hovering = false;\n    cursorPosition = null;\n}\nfunction mouseMove(event) {\n    if (hovering) {\n        const width = clientWidth === undefined ? event.offsetX : clientWidth;\n        const mousePosition = event.offsetX - width / 2;\n        cursorPosition = Math.min(Math.max(minMousePosition, mousePosition), maxMousePosition);\n    }\n}\nconst dispatch = createEventDispatcher();\nfunction mouseClick(event) {\n    const width = clientWidth === undefined ? event.offsetX : clientWidth;\n    const mousePosition = event.offsetX - width / 2;\n    const seconds = mousePosition / pixelsPerSecond;\n    const scrolledSeconds = scroll + seconds;\n    const startAt = Math.min(Math.max(0, scrolledSeconds), duration);\n    dispatch(\"play\", startAt);\n}\n//# sourceMappingURL=Timestamps.svelte.js.map</script>\n\n<style>\n  .timestamps {\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    height: 30px;\n    cursor: pointer;\n  }\n\n  .column {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    display: flex;\n    flex-direction: column;\n    justify-content: flex-start;\n    align-items: center;\n    pointer-events: none;\n  }\n\n  .marker {\n    width: 1px;\n    height: 100%;\n    background-color: gray;\n  }\n\n  .cursor {\n    position: absolute;\n    top: 30px;\n    bottom: 0;\n    left: 0;\n    width: 1px;\n    background-color: gray;\n    z-index: 2;\n  }\n</style>\n\n{#if cursorPosition !== null}\n<div class=\"cursor\" style={`transform: translateX(calc(${cursorPosition}px - 50% + 50vw))`}/>\n{/if}\n\n<div class=\"timestamps\" bind:clientWidth on:mouseover={mouseEnter} on:mouseout|self={mouseLeave} on:mousemove={mouseMove} on:click={mouseClick}>\n  {#each timestamps as {left, mins, secs} (left)}\n    <div class=\"column\" style={`transform: translateX(calc(${left}px - 50%))`} transition:fade>\n      <div class=\"timestamp\">{mins}:{secs}</div>\n      <div class=\"marker\"/>\n    </div>\n  {/each}\n</div>",
    "<script lang=\"ts\">;\nimport { fade } from \"svelte/transition\";\nimport { dragStart } from \"../../../drag\";\nexport let pixelsPerSecond;\nexport let token;\nexport let audioDuration;\nexport let left;\nexport let setToken;\nlet width;\n$: width = token.duration * pixelsPerSecond;\nlet clamped = null;\nlet displayLeftClamp;\nlet displayRightClamp;\n$: displayLeftClamp = clamped === \"LEFT\";\n$: displayRightClamp = clamped === \"RIGHT\";\nfunction panHandler(delta, originalOffset) {\n    const draggedSeconds = delta / pixelsPerSecond;\n    const newOffset = originalOffset - draggedSeconds;\n    const minOffset = 0;\n    const maxOffset = audioDuration - token.duration;\n    if (newOffset < minOffset) {\n        token.start = minOffset;\n        clamped = \"LEFT\";\n    }\n    else if (newOffset > maxOffset) {\n        token.start = maxOffset;\n        clamped = \"RIGHT\";\n    }\n    else {\n        token.start = newOffset;\n        clamped = null;\n    }\n    setToken(token);\n}\nfunction stretchHandler(delta, originalDuration) {\n    const draggedSeconds = delta / pixelsPerSecond;\n    const newDuration = originalDuration + draggedSeconds;\n    const minDuration = 0.1;\n    const maxDuration = audioDuration - token.start;\n    if (newDuration <= minDuration) {\n        token.duration = minDuration;\n        clamped = \"LEFT\";\n    }\n    else if (newDuration >= maxDuration) {\n        token.duration = maxDuration;\n        clamped = \"RIGHT\";\n    }\n    else {\n        token.duration = newDuration;\n        clamped = null;\n    }\n    setToken(token);\n}\nlet stretching = false;\n//# sourceMappingURL=AudioTokenOverlay.svelte.js.map</script>\n\n<style>\n  .panRegion {\n    flex-grow: 1;\n    flex-shrink: 1;\n    cursor: ew-resize;\n  }\n\n  .stretchRegion {\n    width: 40px;\n    max-width: 50%;\n    cursor: e-resize;\n  }\n  .stretchRegion:hover {\n    background-color: rgba(0, 0, 0, 0.2);\n  }\n\n  .audioTokenContainer {\n    display: flex;\n    flex-direction: row;\n    \n    position: absolute;\n    box-sizing: border-box;\n    height: 100%;\n  }\n\n  .leftClamp {\n    position: absolute;\n    top: 0;\n    left: 0;\n    bottom: 0;\n    width: 10px;\n    \n    pointer-events: none;\n    background-image: linear-gradient(90deg, rgba(255,0,0,1) 0%, rgba(255,0,0,0) 100%);\n  }\n  .rightClamp {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    width: 10px;\n\n    pointer-events: none;\n    background-image: linear-gradient(90deg, rgba(255,0,0,0) 0%, rgba(255,0,0,1) 100%);\n  }\n\n  .hidden {\n    opacity: 0;\n  }\n</style>\n\n{#if width > 10}\n  <div class=\"audioTokenContainer\" style={`width: ${width}px; left: ${left}px;`}>\n    <div class=\"panRegion\" on:mousedown|preventDefault={dragStart({\n      button: \"LEFT\",\n      onDrag: panHandler,\n      otherInfoGetter: () => token.start,\n      onEnd: () => clamped = null\n    })}/>\n\n    <div class=\"stretchRegion\" class:hidden={stretching} on:mousedown|preventDefault={dragStart({\n      button: \"LEFT\", \n      onDrag: stretchHandler, \n      otherInfoGetter: () => {stretching = true; return token.duration}, \n      onEnd: () => {stretching = false; clamped = null}\n    })}/>\n\n    {#if displayLeftClamp}\n      <div class=\"leftClamp\" transition:fade/>\n    {/if}\n\n    {#if displayRightClamp}\n      <div class=\"rightClamp\" transition:fade/>\n    {/if}\n  </div>\n{/if}",
    "<script lang=\"ts\">import { dragStart } from \"../../../drag\";\nimport { fade } from \"svelte/transition\";\n;\nexport let pixelsPerSecond;\nexport let token;\nexport let left;\nexport let setToken;\nlet width;\n$: width = token.duration * pixelsPerSecond;\nfunction drag(delta, startDuration) {\n    const draggedSeconds = delta / pixelsPerSecond;\n    token.duration = Math.max(0.1, startDuration + draggedSeconds);\n    setToken(token);\n}\nlet showTime = false;\n//# sourceMappingURL=SilenceTokenOverlay.svelte.js.map</script>\n\n<style>\n  .silenceTokenContainer {\n    cursor: e-resize;\n    display: flex;\n    position: absolute;\n    align-items: center;\n    justify-content: center;\n    box-sizing: border-box;\n    overflow: hidden;\n    height: 100%;\n  }\n</style>\n\n{#if width > 10}\n  <div class=\"silenceTokenContainer\" style={`width: ${width}px; left: ${left}px`} on:mousedown|preventDefault={dragStart({\n    button: \"LEFT\", \n    onDrag: drag, \n    otherInfoGetter: () => {showTime = true; return token.duration}, \n    onEnd: () => {showTime = false}\n  })}>\n    {#if showTime}\n      <div transition:fade>{token.duration.toFixed(2)}s</div>\n    {/if}\n  </div> \n{/if}",
    "<script lang=\"ts\">;\nimport AudioTokenOverlay from \"./AudioTokenOverlay.svelte\";\nimport SilenceTokenOverlay from \"./SilenceTokenOverlay.svelte\";\nexport let tokens;\nexport let pixelsPerSecond;\nexport let scroll;\nexport let audioDuration;\nexport let canvasBounds;\nexport let setToken;\nfunction toStartTokens(tokens, { start, end }) {\n    let timecode = 0;\n    const output = [];\n    for (const token of tokens) {\n        const newTimecode = timecode + token.duration;\n        if (timecode >= end)\n            return output;\n        if (timecode >= start && timecode < end ||\n            newTimecode > start && newTimecode < end ||\n            timecode <= start && newTimecode >= end) {\n            output.push({\n                token,\n                left: (timecode - scroll) * pixelsPerSecond\n            });\n        }\n        timecode = newTimecode;\n    }\n    return output;\n}\nlet startTokens;\n$: startTokens = toStartTokens(tokens, canvasBounds);\n//# sourceMappingURL=TokensOverlay.svelte.js.map</script>\n\n<style>\n  .tokensContainer {\n    position: absolute;\n    top: 30px;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    flex-direction: row;\n    z-index: 1;\n    transform: translateX(50vw);\n  }\n</style>\n\n<div class=\"tokensContainer\">\n  {#each startTokens as {token, left}}\n    {#if token.type === \"AUDIO\"}\n      <AudioTokenOverlay {token} {pixelsPerSecond} {audioDuration} {left} {setToken}/>\n    {:else}\n      <SilenceTokenOverlay {token} {pixelsPerSecond} {left} {setToken}/>\n    {/if}\n  {/each}\n</div>",
    "<script lang=\"ts\">import { onMount } from \"svelte\";\nimport leven from \"fast-levenshtein\";\nimport { toPronunciation } from \"./pronunciation\";\n;\nimport { tweened } from \"svelte/motion\";\nexport let textTokens;\nexport let timingTokens = [];\nexport let data = null;\nlet currentTokenNumber = 0;\nlet currentToken;\n$: currentToken = textTokens[currentTokenNumber];\nlet currentLine;\n$: currentLine = currentToken === undefined ? undefined : currentToken.script;\nlet currentLinePronunciation;\n$: currentLinePronunciation = currentLine === undefined ? undefined : toPronunciation(currentLine);\nlet prevTokenNumber;\n$: prevTokenNumber = currentTokenNumber ? currentTokenNumber - 1 : undefined;\nlet prevToken;\n$: prevToken = prevTokenNumber === undefined ? undefined : textTokens[prevTokenNumber];\nlet prevLine;\n$: prevLine = prevToken === undefined ? undefined : prevToken.script;\nlet prevLinePronunciation;\n$: prevLinePronunciation = prevLine === undefined ? undefined : toPronunciation(prevLine);\nconst minTokenNumber = 1;\nlet maxTokenNumber = 0;\n$: maxTokenNumber = Math.max(maxTokenNumber, currentTokenNumber);\nlet atEnd;\n$: atEnd = currentLine === undefined;\nlet completed = () => { };\nlet speechOffset = 0;\nlet speechStart = 0;\nlet speechEnd = 0;\n//@ts-ignore\nconst recognition = new webkitSpeechRecognition();\nrecognition.continuous = false;\nrecognition.lang = \"en-GB\";\nrecognition.interimResults = false;\nrecognition.maxAlternatives = 1;\nrecognition.onresult = (event) => {\n    recognition.stop();\n    // In case the speechEnd event didn't fire\n    if (speechEnd <= speechStart) {\n        speechEnd = event.timeStamp;\n    }\n    const results = event.results;\n    const item = results.item(0);\n    const { transcript, confidence } = item.item(0);\n    analysis = null;\n    if (atEnd && transcript.toLowerCase() === \"completed\") {\n        completed();\n        return;\n    }\n    const duration = speechEnd - speechStart;\n    if (duration < 500) {\n        analysis = {\n            transcript,\n            decision: \"SHORT\"\n        };\n        return;\n    }\n    const pronunciation = toPronunciation(transcript);\n    const prevDistance = prevLinePronunciation === undefined ? 1000 : leven.get(pronunciation, prevLinePronunciation) / prevLinePronunciation.length;\n    const currDistance = currentLinePronunciation === undefined ? 1000 : leven.get(pronunciation, currentLinePronunciation) / currentLinePronunciation.length;\n    const nonZeroConfidence = confidence || 1;\n    const prevDistanceLowerBound = prevDistance * nonZeroConfidence;\n    const prevDistanceUpperBound = prevDistance / nonZeroConfidence;\n    const currDistanceLowerBound = currDistance * nonZeroConfidence;\n    const currDistanceUpperBound = currDistance / nonZeroConfidence;\n    const maxLower = Math.max(prevDistanceLowerBound, currDistanceLowerBound);\n    const minUpper = Math.min(prevDistanceUpperBound, currDistanceUpperBound);\n    if (maxLower > minUpper) {\n        if (prevDistance !== undefined && (currDistance === undefined || prevDistance < currDistance)) {\n            if (prevDistanceUpperBound !== undefined && prevDistanceUpperBound < 0.5) {\n                const lastToken = timingTokens[timingTokens.length - 1];\n                lastToken.timings.start = speechStart - speechOffset;\n                lastToken.timings.end = speechEnd - speechOffset;\n                analysis = {\n                    transcript,\n                    decision: \"PREVIOUS\"\n                };\n            }\n        }\n        else {\n            if (currDistanceUpperBound !== undefined && currDistanceUpperBound < 0.5) {\n                timingTokens = [...timingTokens, {\n                        ...currentToken,\n                        timings: {\n                            start: speechStart - speechOffset,\n                            end: speechEnd - speechOffset\n                        },\n                        type: \"TIMING\"\n                    }];\n                currentTokenNumber++;\n                analysis = {\n                    transcript,\n                    decision: \"CURRENT\"\n                };\n            }\n        }\n    }\n    if (analysis === null) {\n        analysis = {\n            transcript,\n            decision: \"UNCLEAR\",\n            start: speechStart - speechOffset,\n            end: speechEnd - speechOffset\n        };\n    }\n};\nlet listening = false;\nlet hearing = false;\nrecognition.onerror = (event) => {\n    console.log(\"Speech recognition error: \", event);\n    recognition.stop();\n};\nrecognition.onstart = (event) => {\n    if (speechOffset === 0) {\n        speechOffset = event.timeStamp;\n    }\n};\nrecognition.onend = () => {\n    listening = false;\n    hearing = false;\n    recognition.start();\n};\nrecognition.onaudiostart = () => {\n    listening = true;\n};\nrecognition.onaudioend = () => {\n    listening = false;\n};\nrecognition.onspeechstart = (event) => {\n    speechStart = event.timeStamp;\n    hearing = true;\n};\nrecognition.onspeechend = (event) => {\n    speechEnd = event.timeStamp;\n    hearing = false;\n};\nonMount(() => recognition.start());\nnavigator.mediaDevices.getUserMedia({ audio: {\n        echoCancellation: false,\n        noiseSuppression: false\n    }, video: false })\n    .then(stream => {\n    //@ts-ignore\n    const recorder = new MediaRecorder(stream, {\n        mimeType: \"audio/webm;codecs=pcm\"\n    });\n    recorder.start();\n    completed = () => recorder.stop();\n    recorder.ondataavailable = (event) => {\n        data = event.data;\n        recognition.onend = () => { };\n        recognition.stop();\n    };\n}).catch((error) => {\n    console.log(error.message);\n    if (error.message === \"Permission denied\") {\n        recognition.onerror = () => { };\n        alert(`Audio error: '${error.message}'. Audio permission is required because that's the whole point of the app. Click on the i in the address bar to allow then reload the page`);\n    }\n    else {\n        alert(`Audio error: '${error.message}'.`);\n    }\n});\nlet analysis = null;\nlet progress;\n$: progress = 100 * currentTokenNumber / textTokens.length;\nconst tweenedProgress = tweened(progress);\n$: tweenedProgress.set(progress);\nfunction oldLineOverride() {\n    const { start, end, transcript } = analysis;\n    const lastToken = timingTokens[timingTokens.length - 1];\n    lastToken.timings.start = start;\n    lastToken.timings.end = end;\n    analysis = {\n        transcript,\n        decision: \"PREVIOUS\"\n    };\n}\nfunction newLineOverride() {\n    const { start, end, transcript } = analysis;\n    timingTokens = [...timingTokens, {\n            ...currentToken,\n            timings: { start, end },\n            type: \"TIMING\"\n        }];\n    analysis = {\n        transcript,\n        decision: \"CURRENT\"\n    };\n    currentTokenNumber++;\n}\nlet bottomPrompt;\n$: bottomPrompt = currentTokenNumber === 0 ? \"To begin, say:\" : atEnd ? \"Or if you're done, say:\" : \"Or say the next line to move on:\";\nlet bottomLine;\n$: bottomLine = atEnd ? \"Completed\" : currentLine || \" \";\nconst decisionText = {\n    \"CURRENT\": \"I think that was the new line.\",\n    \"PREVIOUS\": \"I think that was the old line.\",\n    \"UNCLEAR\": \"I can't tell which line that is. Try again or use the buttons below.\",\n    \"SHORT\": \"I didn't notice you start talking. Try waiting a second longer between lines.\"\n};\nlet decision;\n$: decision = analysis ? decisionText[analysis.decision] : \"NONE\";\n//# sourceMappingURL=AudioRecorder.svelte.js.map</script>\n\n<style>\n  .circleContainer {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n  }\n\n  .circle {\n    width: 20px;\n    height: 20px;\n    border: 1px solid black;\n    border-radius: 50%;\n    margin: 20px;\n  }\n\n  .red {\n    background-color: red;\n  }\n\n  .green {\n    background-color: green;\n  }\n\n  .column {\n    display: flex;\n    flex-direction: column;\n    justify-content: flex-start;\n    align-items: center;\n    height: 100%;\n    width: 100%;\n    text-align: center;\n  }\n\n  .prompt {\n    font-size: 20px;\n    margin: 20px 20px 10px 20px;\n  }\n\n  .script {\n    font-size: 36px;\n  }\n\n  .transcript {\n    font-size: 20px;\n    margin: 20px;\n  }\n\n  .decision {\n    font-size: 20px;\n    margin: 20px;\n  }\n\n  .spacer {\n    height: 100px;\n    flex-shrink: 1;\n    flex-grow: 1;\n  }\n\n  .bar {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n\n    background-color: green;\n  }\n\n  .barContainer {\n    position: relative;\n    width: 100%;\n    height: 10px;\n    flex-shrink: 0;\n    flex-grow: 0;\n  }\n\n  .override {\n    display: flex;\n    flex-direction: row;\n    justify-content: center;\n  }\n\n  .overrideButton {\n    margin: 10px;\n  }\n\n  .hidden {\n    opacity: 0;\n  }\n\n  .back {\n    position: fixed;\n    top: 50vh;\n    left: 10px;\n    transform: translateY(-50%);\n    font-size: 30px;\n  }\n\n  .forwards {\n    position: fixed;\n    top: 50vh;\n    right: 10px;\n    transform: translateY(-50%);\n    font-size: 30px;\n  }\n</style>\n\n<button class=\"back\" disabled={hearing || currentTokenNumber <= minTokenNumber} on:click={() => currentTokenNumber--}>←</button>\n<button class=\"forwards\" disabled={hearing || currentTokenNumber >= maxTokenNumber} on:click={() => currentTokenNumber++}>→</button>\n\n<div class=\"column\">\n  <div class=\"prompt\" class:hidden={currentTokenNumber === 0}>If you didn't like your delivery of the last line, say it again:</div>\n  <div class=\"script\" class:hidden={currentTokenNumber === 0}>{@html prevLine || \"NONE\"}</div>\n\n  <div class=\"spacer\"/>\n\n  <div class=\"prompt\">{bottomPrompt}</div>\n  <div class=\"script\">{@html bottomLine}</div>\n\n  <div class=\"spacer\"/>\n\n  <div class=\"circleContainer\">\n    <div class=\"circle\" class:red={listening}/>\n    <div class=\"circle\" class:green={hearing}/>\n  </div>\n\n  <div class=\"transcript\">\n    <span class:hidden={analysis === null}>I heard <b>{analysis ? analysis.transcript : \"NONE\"}</b></span>\n  </div>\n\n  <div class=\"decision\" class:hidden={analysis === null}>{decision}</div>\n\n  <div class=\"override\">\n    {#if analysis && analysis.decision === \"UNCLEAR\"}\n      {#if currentTokenNumber > 0}\n        <button class=\"overrideButton\" on:click={oldLineOverride}>Old Line</button>\n      {/if}\n\n      {#if atEnd}\n        <button class=\"overrideButton\" on:click={completed}>Completed</button>\n      {:else}\n        <button class=\"overrideButton\" on:click={newLineOverride}>New Line</button>\n      {/if}\n    {/if}\n  </div>\n\n  <div class=\"spacer\"/>\n\n  <div class=\"barContainer\">\n    <div class=\"bar\" style={`width: ${$tweenedProgress}%`}/>\n  </div>\n</div>\n\n\n\n",
    "<script lang=\"ts\">;\nimport { computeScriptTokens } from \"./tokenizer\";\nlet script = \"\";\nfunction submit() {\n    tokens = computeScriptTokens(script);\n}\nexport let tokens;\n//# sourceMappingURL=ScriptEntry.svelte.js.map</script>\n\n<style>\n  .column {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n  }\n\n  textarea {\n    width: 90%;\n    flex-grow: 1;\n    flex-shrink: 1;\n    margin: 12px;\n    padding: 12px;\n  }\n</style>\n\n<div class=\"column\">\n  <textarea bind:value={script} placeholder=\"Paste your script in here (supports markdown)\"/>\n  <button on:click={submit}>Submit</button>\n</div>\n"
  ],
  "names": [],
  "mappings": "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"
}